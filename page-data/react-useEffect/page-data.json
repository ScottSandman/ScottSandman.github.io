{"componentChunkName":"component---src-templates-blog-template-js","path":"/react-useEffect","result":{"data":{"markdownRemark":{"frontmatter":{"author":"Scott Sandman","date":"2020-04-29","title":"React Hook - useEffect","path":"/react-useEffect"},"html":"<p>In the last post, we discussed the use of React hooks in lieu of using the class method and props to manage and update state. To get a better understanding of the benefits of using hooks, we need to take another look at a class method:</p>\n<pre><code class=\"language-JavaScript\">import React from \"react\"\n\nclass App extends React.Component {\n  constructor(props) {\n    super(props)\n\n    this.state = {\n      firstName: \"Henry\",\n      lastName: \"Smith\",\n    }\n  }\n  render() {\n    return (\n      &#x3C;div>\n        &#x3C;h1>First Name: {this.state.firstName}&#x3C;/h1>\n        &#x3C;h2>Last Name: {this.state.lastName}&#x3C;/h2>\n      &#x3C;/div>\n    )\n  }\n}\n\nexport default App\n</code></pre>\n<p>As you can see, a constructor is used to handle props, this.state is used to set initial values and this.state.firstName calls the state for rendering. Simple enough. But what if we want to manage the state throughout the lifecycle of our app? At this point we are talking about writing methods, getter methods, implementing this.setState() and using an assortment of predefined lifecycle methods such as:</p>\n<pre><code class=\"language-JavaScript\">componentWillMount()\ncomponentDidMount()\ncomponentWillUpdate()\ncomponentWillUnmount()\n</code></pre>\n<p>It's getting quite a bit more involved now to set and manage our state; not to mention the amount of code is growing which means the chances of bugs is increasing. Enter the magic of hooks. If you recall from the previous post, useState not only allows us to set our state, but also defines an update method:</p>\n<pre><code class=\"language-JavaScript\">import React, { useState } from \"react\"\n\nfunction App() {\n  const [firstName, setFirstName] = useState(\"Henry\")\n  const [lastName, setLastName] = useState(\"Smith\")\n\n  return (\n    &#x3C;div>\n      &#x3C;h1>First Name: {firstName}&#x3C;/h1>\n      &#x3C;h2>Last Name: {lastName}&#x3C;/h2>\n    &#x3C;/div>\n  )\n}\n</code></pre>\n<p>At this point in the class method, we would need to begin adding all of our lifecycle methods to set and control state. Say hello to the hook, useEffect() which replaces them all. Yup, one hook to replace all of those predefined lifecycle methods. UseEffect takes two parameters; the first being a callback function. We'll talk about the second parameter in a moment.</p>\n<pre><code class=\"language-JavaScript\">import React, { useState, useEffect } from \"react\"\n\nfunction App() {\n  const [firstName, setFirstName] = useState(\"\")\n  const [lastName, setLastName] = useState(\"\") //initial state set to empty strings\n\n  useEffect(() => {\n    setFirstName(\"Henry\")\n    setLastName(\"Smith\") //set state in useEffect\n  })\n\n  return (\n    &#x3C;div>\n      &#x3C;h1>First Name: {firstName}&#x3C;/h1>\n      &#x3C;h2>Last Name: {lastName}&#x3C;/h2>\n    &#x3C;/div>\n  )\n}\n</code></pre>\n<p>In the example above, we set our initial states to empty strings and then updated them in useEffect() which executes when the page initially loads. This brings us to the second parameter. If we don't provide one, useEffect() will go into an infinite loop as it runs each time the app renders. By adding an empty array as a second parameter, we can tell useEffect to run only the single time.</p>\n<pre><code class=\"language-JavaScript\">import React, { useState, useEffect } from \"react\"\n\nfunction App() {\n  const [firstName, setFirstName] = useState(\"\")\n  const [lastName, setLastName] = useState(\"\")\n\n  useEffect(() => {\n    setFirstName(\"Henry\")\n    setLastName(\"Smith\")\n  }, []) //use empty array to execute just once\n\n  return (\n    &#x3C;div>\n      &#x3C;h1>First Name: {firstName}&#x3C;/h1>\n      &#x3C;h2>Last Name: {lastName}&#x3C;/h2>\n    &#x3C;/div>\n  )\n}\n</code></pre>\n<p>However, if we want useEffect() to monitor our state, we simply need to tell it which state items to watch. We do this by adding them into the second parameter array. Then, anytime there is a call to update the state we are monitoring, useEffect() will execute.</p>\n<pre><code class=\"language-JavaScript\">import React, { useState, useEffect } from \"react\"\n\nfunction App() {\n  const [firstName, setFirstName] = useState(\"\")\n  const [lastName, setLastName] = useState(\"\")\n\n  useEffect(() => {\n    setFirstName(\"Henry\")\n    setLastName(\"Smith\")\n  }, [firstName, lastName]) //monitors for changes\n\n  return (\n    &#x3C;div>\n      &#x3C;h1>First Name: {firstName}&#x3C;/h1>\n      &#x3C;h2>Last Name: {lastName}&#x3C;/h2>\n    &#x3C;/div>\n  )\n}\n</code></pre>\n<p>This is a pretty simple example of useEffect(), but I think it demonstrates enough to show its ease of use and elegance. Add in the fact useEffect() reduces the amount of code we have to generate, I'm all for it. How about you?</p>"},"site":{"siteMetadata":{"image":"/images/ravenel.jpg","siteUrl":"https://scottsandman.github.io"}}},"pageContext":{}}}