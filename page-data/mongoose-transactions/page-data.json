{"componentChunkName":"component---src-templates-blog-template-js","path":"/mongoose-transactions","result":{"data":{"markdownRemark":{"frontmatter":{"author":"Scott Sandman","date":"2020-11-27","title":"Mongoose and Transactions","path":"/mongoose-transactions"},"html":"<p>I was developing a project recently when I came across an issue I hadn't previously had the pleasure of solving. Due to the sensitive nature of portions of the data, multiple collections were utilized in MongoDB Atlas. This meant when working with an instance, two create, two update, two findOneAndUpdate... methods would be required. This lead to the question, \"What if one or both of the methods were to fail?\" Obviously, this would lead to a mismatched data when working with the instance and potentially crash the application.</p>\n<p>So I began researching how to handle the \"what if's\" and came across a number of devs suggesting the use of Promise.all to obtain atomicity (one fails, they all fail). This sounded like a good solution so I implemented it. The Promise.all worked as stated. If a portion of the instance failed, the instance would error. However, if it was the second of the two methods, the first method still persisted leading to mismatched data. Back to the Google search.</p>\n<p>I also reached out to my former bootcamp instructor to see if he had any suggestions. He sent me a link to transactions in MongoDB. \"Distributed Transactions and Multi-Document Transactions\" as it were. Given that I had already implemented Mongoose, I directed my attention to their docs. It was there I found answers. However, those answers would require some manipulation before transforming into solutions.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"></code></pre></div>"},"site":{"siteMetadata":{"image":"/ravenel.jpg","siteUrl":"https://scottsandman.github.io"}}},"pageContext":{}},"staticQueryHashes":[]}